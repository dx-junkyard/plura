# 会話まわりのプロンプト一覧

「全然会話ができない」場合の確認用に、現在の会話・相槌・分析で使っているプロンプトとメッセージを書き出しています。

---

## 1. 相槌メッセージ（記録送信直後に返す文言）

**場所**: `backend/app/schemas/raw_log.py` — `AckResponse.create_ack()`

送信した内容の **intent**（Context Analyzer の結果）に応じて、以下のいずれかがランダムで1つ返ります。

| intent | 候補メッセージ |
|--------|----------------|
| **log**（記録） | 「記録しました。」「受け取りました。」 |
| **vent**（吐き出し） | 「それは大変でしたね。」「お気持ち、受け止めました。」「聞かせてくれてありがとうございます。」 |
| **structure**（整理） | 「整理を始めますね。」「承知しました。」 |
| **None**（解析前/失敗時） | 「受領しました。」 |

※ 実際に返るのは **1つだけ**（各リストから `random.choice`）。

---

## 2. タイムライン「続き」で表示する固定メッセージ

**場所**: `frontend/src/components/ThoughtStream.tsx`

タイムラインでログを選んで「続き」を表示するとき、**システムの相槌**として常に次の文言を使っています。

- **固定文**: `受け取りました。`

（バックエンドの相槌とは別で、フロントでハードコードされています。）

---

## 3. Context Analyzer（文脈解析）

**役割**: 入力テキストから intent / emotions / topics / tags などを抽出。FAST モデル使用。

**場所**: `backend/app/services/layer1/context_analyzer.py`

### システムプロンプト（`_get_system_prompt`）

```
あなたはPLURAの文脈解析エンジンです。
ユーザーの入力テキストを解析し、以下の情報を抽出してください。

必ず以下のJSON形式で応答してください:
{
    "intent": "log" | "vent" | "structure",
    "emotions": ["emotion1", "emotion2"],
    "emotion_scores": {"emotion1": 0.8, "emotion2": 0.5},
    "topics": ["topic1", "topic2"],
    "tags": ["Work", "Project-A", "Idea"],
    "summary": "1行要約",
    "emotional_score": 0.0
}

intent の判定基準:
- "log": 単に記録・メモしたい（事実の記述、淡々とした報告）
- "vent": 愚痴・不満を吐き出したい（感情的な表現、不満、フラストレーション）
- "structure": 整理・分析したい（「どうすれば」「なぜ」などの思考整理）

emotions の選択肢:
- frustrated (焦り)
- angry (怒り)
- achieved (達成感)
- anxious (不安)
- confused (困惑)
- relieved (安堵)
- excited (興奮)
- neutral (中立)

topics はビジネス・業務に関連するトピックを抽出してください。
例: プロジェクト管理、人事評価、技術的負債、顧客対応、チームコミュニケーションなど

tags は再利用可能な短い語を抽出し、カテゴリ（例: Work / Private）と対象（例: Project名 / 技術）を含めてください。
```

### ユーザープロンプト（`_build_analysis_prompt`）

```
以下のテキストを解析してください:

---
{ユーザーが入力した content}
---

JSON形式で解析結果を返してください。
```

---

## 4. Structural Analyzer（構造分析・深掘り問い）

**役割**: 直近履歴と「構造的課題」を踏まえ、関係性判定・課題更新・**probing_question**（深掘り問い／回答）を生成。DEEP モデル使用。

**場所**: `backend/app/services/layer2/structural_analyzer.py`

### システムプロンプト（`_get_system_prompt`）

```
あなたはPLURAの構造的分析エンジンです。
ユーザーの入力を、過去の会話コンテキストを踏まえて分析し、
「構造的課題」を特定・更新していきます。

分析は以下の手順で行ってください:

## Step 0: インタラクション判定
今回の入力が以下のどれに当たるか判断してください（複数可だが主要なものを1つ選ぶ）:
- QUESTION: 具体的な情報ややり方を尋ねている
- BRAINSTORM: アイデア出し・検討・選択肢を探している
- REFLECTION: 思考整理・振り返り・自分の考えを深めたい
- OTHER: 上記以外

## Step 1: 関係性判定 (Relationship Classification)
今回の入力は、直前の仮説に対してどのような関係にあるか判定してください。

- ADDITIVE (深化): 同じ構造的課題に対する追加情報・詳細を提供している
- PARALLEL (並列・亜種): 同じカテゴリの課題だが、別の事例・側面を示している
  例: Aさんとのトラブル → Bさんとも同様のトラブル
- CORRECTION (訂正): 以前の仮説が間違っていた、あるいは状況が変化したことを示唆
- NEW (新規): 全く新しいトピック、以前の議論と無関係

## Step 2: 構造的理解の統合・更新 (Update Understanding)
判定結果に基づき、「現在の構造的課題（Current Structural Issue）」を書き換えてください。

- ADDITIVEの場合: より詳細・具体的な課題定義に更新
- PARALLELの場合: 個別の事象を包含する、より抽象度の高い課題名に更新
  例：「A課長の承認フロー」→「組織全体の権限委譲の欠如」
- CORRECTIONの場合: 新しい情報に基づいて課題を再定義
- NEWの場合: 新しい構造的課題を定義

## Step 3: 問いの生成
更新された理解に基づき、さらに深掘りするための質問を1つ作成してください。
質問は、ユーザーの思考を促し、構造的な問題をより明確にするものにしてください。

必ず以下のJSON形式で応答してください:
{
    "relationship_type": "ADDITIVE" | "PARALLEL" | "CORRECTION" | "NEW",
    "relationship_reason": "判定理由の説明",
    "updated_structural_issue": "更新された構造的課題の定義",
    "probing_question": "QUESTIONの場合はできる限り具体的な回答、もしくは3つ以内の調査手順。その他の場合は深掘りのための問い。"
}

重要: 「問い」を作る際は次を守ってください。
- 決まり文句を避け、ユーザーの言葉や話題を1つ以上含める。
- 指示語だけにせず、何についての問い/回答かを明示する。
- 共感的で圧迫感のないトーンにする。
- QUESTIONの場合: まず簡潔に答えられる範囲で答える。確信が持てないときは「今すぐできる調べ方」を2〜3個、具体的キーワード付きで提案する。
- BRAINSTORM/REFLECTIONの場合: 新しい洞察が出るように理由・背景・具体的状況を尋ねる。
```

### ユーザープロンプト（`_build_analysis_prompt`）

- 直近の会話履歴がある場合:
  ```
  ## 直近の会話履歴（要約）:
  1. {要約1}
  2. {要約2}
  ...
  ```
- 直前の構造的課題（仮説）がある場合:
  ```
  ## 直前の構造的課題（仮説）:
  {previous_hypothesis}
  ```
  ない場合:
  ```
  ## 直前の構造的課題（仮説）:
  （初回の入力のため、仮説なし）
  ```
- 共通:
  ```
  ## 今回の入力:
  ---
  {current_log}
  ---

  上記を分析し、JSON形式で結果を返してください。
  ```

---

## 5. Structural Analyzer フォールバック（LLM 未使用時）

**場所**: 同上 `_fallback_analyze()`

LLM が使えないときのルールベースです。`probing_question` の例のみ抜粋します。

- **初回・質問でない**:  
  `「{simple_issue}」について、今いちばん知りたいことや困っている場面はどこですか？`
- **初回・質問**:  
  `今すぐできる調べ方:\n1) 公式/信頼できるドキュメントで「{simple_issue}」を検索\n2) 事例ブログで『{simple_issue} とは』『{simple_issue} 仕組み』を調べる\n3) わかったことを一文でまとめてから次の疑問を洗い出す`
- **訂正キーワード検出・質問でない**:  
  `「{simple_issue}」になった背景やきっかけを教えてもらえますか？`
- **訂正・質問**:  
  `変化のポイントをもう少し教えてください。何が変わり、どこで困っていますか？`
- **並列キーワード検出・質問でない**:  
  `似たケースが他にもあるとのことですが、「{expanded}」で共通して困る場面は何でしょう？`
- **並列・質問**:  
  `複数ケースで共通する論点を1つ挙げるなら何ですか？それを手がかりに調べてみましょう。`
- **デフォルト（ADDITIVE）・質問でない**:  
  `「{previous_hypothesis or simple_issue}」をもう少し具体的にするなら、どんな状況・登場人物が関わっていますか？`
- **デフォルト・質問**:  
  `今わかっていることを一文でまとめるとどうなりますか？次に調べるキーワードを2つ挙げてみてください。`

※ `simple_issue` は入力の先頭50文字から生成、`expanded` は直前仮説の拡張表現です。

---

## 6. 会話フロー上のポイント

- **ユーザーが送信** → ログ保存 → **Context Analyzer** で intent 等を算出 → **相槌**（上記 1）を返す。
- 並行して **Structural Analyzer**（Celery）が実行され、完了すると **probing_question** がチャットに表示される。
- 表示される「会話」は次の3つ:
  1. **相槌**: 上記 1 のいずれか（API レスポンスの `message`）
  2. **分析中表示**: 「考えを整理しています...」等（フロントのラベル）
  3. **深掘り問い**: Structural Analyzer の `probing_question`（またはフォールバックの問い）

「全然会話ができない」場合の確認ポイント例:

- 相槌が出ない → `AckResponse.create_ack` と intent の取得（Context Analyzer の成否・フォールバック）
- 深掘り問いが出ない → Structural Analyzer の実行（Celery）、DEEP モデル／API キー、フォールバックの条件
- 文言を変えたい → 上記 1〜5 の該当プロンプト／メッセージを編集

必要なら、特定の「出したい会話」に合わせてプロンプト案も書けます。
